schools_dat <- list(J = 8,
y = c(28,  8, -3,  7, -1,  1, 18, 12),
sigma = c(15, 10, 16, 11,  9, 11, 10, 18))
fit <- stan(file = '8schools.stan', data = schools_dat)
print(fit)
plot(fit)
library(rstan)
schools_dat <- list(J = 8,
y = c(28,  8, -3,  7, -1,  1, 18, 12),
sigma = c(15, 10, 16, 11,  9, 11, 10, 18))
fit <- stan(file = '8schools.stan', data = schools_dat)
print(fit)
plot(fit)
file.rename("~/.R/Makevars", "~/.R/old_Makevars")
schools_dat <- list(J = 8,
y = c(28,  8, -3,  7, -1,  1, 18, 12),
sigma = c(15, 10, 16, 11,  9, 11, 10, 18))
fit <- stan(file = '8schools.stan', data = schools_dat)
print(fit)
plot(fit)
v
Compilation ERROR, function(s)/method(s) not created! In file included from file1bff50170204.cpp:8
file.edit("~/.R/Makevars")
file.edit("~/.R/Makevars")
library(rstan)
file.rename("~/.R/Makevars", "~/.R/old_Makevars")
Sys.setenv(USE_CXX14=1)
schools_dat <- list(J = 8,
y = c(28,  8, -3,  7, -1,  1, 18, 12),
sigma = c(15, 10, 16, 11,  9, 11, 10, 18))
fit <- stan(file = '8schools.stan', data = schools_dat)
print(fit)
plot(fit)
# load library
library(rstan)
Sys.setenv(USE_CXX14=1)
options(warn=-1, message =-1)
library(dplyr); library(ggplot2); library(rstan); library(reshape2)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
source('model.R')
source('subFxs/loadFxs.R')
source("subFxs/plotThemes.R")
source("subFxs/wtwSettings.R")
source('suBFxs/paraFxs.R')
# load all data
allData = loadAllData()
hdrData = allData$hdrData
trialData = allData$trialData
# select data
thisTrialData = trialData[[1]]
bkIdx = 1
thisBlockData = thisTrialData[thisTrialData$blockNum == bkIdx,]
# prepare arguments
thisCond = ifelse(unique(thisBlockData$condition) == 'HP', conditions[1], conditions[2])
waitDurations = thisBlockData$timeWaited
waitDurations[thisBlockData$trialEarnings == 5] = thisBlockData$scheduledWait[thisBlockData$trialEarnings == 5]
nTrial = nrow(thisBlockData)
inputData = list(nTrial = nTrial,
rewardDelays = thisBlockData$scheduledWait,
trialEarnings = thisBlockData$trialEarnings,
waitDurations = waitDurations
)
stepDuration = 0.5
otherPara = getOtherPara(thisCond, stepDuration)
source('model.R')
source('subFxs/loadFxs.R')
source("subFxs/plotThemes.R")
source("subFxs/wtwSettings.R")
source('suBFxs/paraFxs.R')
# load all data
allData = loadAllData()
hdrData = allData$hdrData
trialData = allData$trialData
# select data
thisTrialData = trialData[[1]]
bkIdx = 1
thisBlockData = thisTrialData[thisTrialData$blockNum == bkIdx,]
# input
sigma = 1
stepDuration = 0.5
waitRate = 0.9
rewardDelays = thisBlockData$scheduledWait
# toy stan model
test_string = "
functions {
vector action_rng(real waitRate, real stepDuration,vector rewardDelays, real sigma) {
vector[num_elements(rewardDelays)] action;
vector[num_elements(rewardDelays)] output;
real endStep;
real rewardDelay;
for(n in 1 : num_elements(rewardDelays)){
rewardDelay  = rewardDelays[n];
endStep = round(rewardDelay / stepDuration);
for(t in 1 : 10){
if(uniform_rng(0, 1) > waitRate ){
action[n] = 0;
break;
}
}
output[n] <- normal_rng(action[n], sigma);
}
return output;
}
}
data {
}
parameters {
}
model {
}
"
compiled_function <- stan_model(model_code = test_string) # you could use file = "path/to/yourfile.stan" if you have saved it as so
# And make the function available to the user in R
expose_stan_functions(compiled_function)
library(rstan)
Sys.setenv(USE_CXX14=1)
options(warn=-1, message =-1)
library(dplyr); library(ggplot2); library(rstan); library(reshape2)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
# input
sigma = 1
stepDuration = 0.5
waitRate = 0.9
rewardDelays = thisBlockData$scheduledWait
# toy stan model
test_string = "
functions {
vector action_rng(real waitRate, real stepDuration,vector rewardDelays, real sigma) {
vector[num_elements(rewardDelays)] action;
vector[num_elements(rewardDelays)] output;
real endStep;
real rewardDelay;
for(n in 1 : num_elements(rewardDelays)){
rewardDelay  = rewardDelays[n];
endStep = round(rewardDelay / stepDuration);
for(t in 1 : 10){
if(uniform_rng(0, 1) > waitRate ){
action[n] = 0;
break;
}
}
output[n] <- normal_rng(action[n], sigma);
}
return output;
}
}
data {
}
parameters {
}
model {
}
"
compiled_function <- stan_model(model_code = test_string) # you could use file = "path/to/yourfile.stan" if you have saved it as so
library('ggplot2')
source('model.R')
source('subFxs/loadFxs.R')
source("subFxs/plotThemes.R")
source("subFxs/wtwSettings.R")
source('suBFxs/paraFxs.R')
# load all data
allData = loadAllData()
hdrData = allData$hdrData
trialData = allData$trialData
# select data
thisTrialData = trialData[[1]]
bkIdx = 1
thisBlockData = thisTrialData[thisTrialData$blockNum == bkIdx,]
# prepare arguments
thisCond = ifelse(unique(thisBlockData$condition) == 'HP', conditions[1], conditions[2])
waitDurations = thisBlockData$timeWaited
waitDurations[thisBlockData$trialEarnings == 5] = thisBlockData$scheduledWait[thisBlockData$trialEarnings == 5]
nTrial = nrow(thisBlockData)
inputData = list(nTrial = nTrial,
rewardDelays = thisBlockData$scheduledWait,
trialEarnings = thisBlockData$trialEarnings,
waitDurations = waitDurations
)
stepDuration = 0.5
otherPara = getOtherPara(thisCond, stepDuration)
library('ggplot2')
source('model.R')
source('subFxs/loadFxs.R')
source("subFxs/plotThemes.R")
source("subFxs/wtwSettings.R")
source('suBFxs/paraFxs.R')
library('ggplot2')
source('model.R')
source('subFxs/loadFxs.R')
source("subFxs/plotThemes.R")
source("subFxs/wtwSettings.R")
source('suBFxs/paraFxs.R')
# load all data
allData = loadAllData()
hdrData = allData$hdrData
trialData = allData$trialData
library('ggplot2')
source('model.R')
source('subFxs/loadFxs.R')
source("subFxs/plotThemes.R")
source("subFxs/wtwSettings.R")
source('suBFxs/paraFxs.R')
library('ggplot2')
source('model.R')
source('subFxs/loadFxs.R')
source("subFxs/plotThemes.R")
source("subFxs/wtwSettings.R")
source('suBFxs/paraFxs.R')
# load all data
allData = loadAllData()
hdrData = allData$hdrData
trialData = allData$trialData
# select data
thisTrialData = trialData[[1]]
bkIdx = 1
thisBlockData = thisTrialData[thisTrialData$blockNum == bkIdx,]
# prepare arguments
thisCond = ifelse(unique(thisBlockData$condition) == 'HP', conditions[1], conditions[2])
waitDurations = thisBlockData$timeWaited
waitDurations[thisBlockData$trialEarnings == 5] = thisBlockData$scheduledWait[thisBlockData$trialEarnings == 5]
nTrial = nrow(thisBlockData)
inputData = list(nTrial = nTrial,
rewardDelays = thisBlockData$scheduledWait,
trialEarnings = thisBlockData$trialEarnings,
waitDurations = waitDurations
)
stepDuration = 0.5
otherPara = getOtherPara(thisCond, stepDuration)
library('ggplot2')
source('model.R')
source('subFxs/loadFxs.R')
source("subFxs/plotThemes.R")
source("subFxs/wtwSettings.R")
source('suBFxs/paraFxs.R')
# load all data
allData = loadAllData()
hdrData = allData$hdrData
trialData = allData$trialData
# select data
thisTrialData = trialData[[1]]
bkIdx = 1
thisBlockData = thisTrialData[thisTrialData$blockNum == bkIdx,]
# prepare arguments
thisCond = ifelse(unique(thisBlockData$condition) == 'HP', conditions[1], conditions[2])
waitDurations = thisBlockData$timeWaited
waitDurations[thisBlockData$trialEarnings == 5] = thisBlockData$scheduledWait[thisBlockData$trialEarnings == 5]
nTrial = nrow(thisBlockData)
inputData = list(nTrial = nTrial,
rewardDelays = thisBlockData$scheduledWait,
trialEarnings = thisBlockData$trialEarnings,
waitDurations = waitDurations
)
stepDuration = 0.5
otherPara = getOtherPara(thisCond, stepDuration)
source('suBFxs/paraFxs.R')
source('subFxs/wtwSettings.R')
source('subFxs/model.R')
source('subFxs/paraFxs.R')
options(warn=-1, message =-1) # default settings borrowed somewhere
library(dplyr); library(ggplot2);library(reshape2) # load libraries
Sys.setenv(USE_CXX14=1) # making rstan working on this device
rstan_options(auto_write = TRUE) # default settings borrowed somewhere
options(mc.cores = parallel::detectCores())# enable multi-core precessors
modelString = "
data {
// depending on the condition
real wIni;
int tMax;
int nTimeStep; // since round returns real here, so nTimeStep != tMax / stepDuration
// depending on each subject
int N; // number of trials
vector[N] timeWaited;
vector[N] trialEarnings;
int nTimePoints[N]; // since tMax / stepDuration is real
}
transformed data {
// constant
real stepDuration = 0.5;
real iti = 2;
real tokenValue = 10;
}
parameters {
real<lower = 0, upper = 1> phi;
real<lower = 1, upper = 30> tau;
real<lower = 0, upper = 1> gamma;
}
transformed parameters{
// initialize action values
vector[nTimeStep] Qwait = rep_vector(wIni, nTimeStep);
real Qquit = wIni * gamma ^(iti / stepDuration);
// initialize recordings of action values
matrix[nTimeStep, N] Qwaits = to_matrix(rep_vector(0, nTimeStep * N), nTimeStep, N);
vector[nTimeStep] Qquits = rep_vector(0, N);
//
vector[nTimeStep] gammaList = gamma ^ (nTimeStep - (1 : nTimeStep));
// loop over trial
real trialReward;
real nextWaitRateHat;
for(tIdx in 1 : N){
// determine nTimePoint
int nTimePoint = nTimePoints[tIdx];
// update and track action values
if(trialEarnings[tIdx] > 0){
trialReward = tokenValue;
Qwait[1 : nTimePoint] = (1 - phi) * Qwait[1 : nTimePoint] + phi * trialReward * gamma ^ gammaList[(nTimeStep - nTimePoint + 1):nTimeStep];
}else{
nextWaitRateHat =  1 / sum(1  + exp((Qquit - Qwait[1])* tau));
trialReward = nextWaitRateHat * Qwait[1] * gamma ^(iti / stepDuration) + (1 - nextWaitRateHat) * Qquit * gamma ^ gammaList[(nTimeStep - nTimePoint + 1):(nTimeStep - 1)];
Qquit =  (1 - phi) * Qquit + phi *  trialReward;
if(nTimePoint > 1){
Qwait[1 : (nTimePoint - 1)] = (1 - phi) * Qwait[1 : (nTimePoint - 1)] + phi * trialReward * gamma ^ reverse(1 : nTimePoint - 1.0);
}
}
Qwaits[,tIdx] = Qwait;
Qquits[tIdx] = Qquit;
}// end of the loop
}
model {
phi ~ uniform(0, 1);
tau ~ uniform(1, 30);
gamma ~ uniform(0, 1);
// calculate the likelihood
for(tIdx in 1 : N){
int i = 1;
int action;
while(i <= nTimePoints[tIdx]){
if(trialEarnings[tIdx] == 0 && i == nTimePoints[tIdx]){
action = 2; // quit
}else{
action = 1; // wait
}
vector[2] values;
values[1] = Qwaits[i, tIdx];
values[2] = Qquits[tIdx];
action ~ categorical_logit(values);
i＝ i＋ 1;
}
}
}
generated quantities {
// initialize log_lik
matrix[nTimeStep, N] = 0;
// loop over trials
for(tIdx in 1 : N){
int i = 1;
int action;
while(i <= nTimePoints[tIdx]){
if(trialEarnings[tIdx] == 0 && i == nTimePoints[tIdx]){
action = 2; // quit
}else{
action = 1; // wait
}
vector[2] values;
values[1] = Qwaits[i, tIdx];
values[2] = Qquits[tIdx];
log_lik[i, tIdx] =categorical_logit_lpmf(action | values);
i＝ i＋ 1;
}
}
real LL_all=sum(to_vector(log_lik));
}
"
# fitting the model
source('subFxs/wtwSettings.R')
source('subFxs/fittingFxs.R')
load('outputs/fixInputSimData/initialSpace.RData') # need nComb(for loop), wIni, nPara(for initialize solutions)
# choose the condition
condIdx = 1
cond = conditions[condIdx]
wIni = wInis[[cond]]
tMax = ifelse(cond == 'HP', tMaxs[1], tMaxs[2])
nTimeStep = tMax / stepDuration
if(condIdx == 1){
load('outputs/fixInputSimData/rawHPData.RData')
timeWaitedList = rawHPData$timeWaited[,1,]
trialEarningsList = rawHPData$trialEarnings[,1,]
rm(rawHPData)
}else{
load('outputs/fixInputSimData/rawLPData.RData')
timeWaitedList = rawLPData$timeWaited[,1,]
trialEarningsList = rawLPData$trialEarnings[,1,]
rm(rawLPData)
}
# choose the combIdx
combIdx = 1
timeWaited = timeWaitedList[combIdx,];
trialEarnings = trialEarningsList[combIdx,];
nTimePoints = round(ifelse(trialEarnings >0, ceiling(timeWaited / stepDuration), floor(timeWaited / stepDuration) + 1))
data_list <- list(tMax = tMax,
wIni = wIni,
nTimeStep = nTimeStep,
N = length(timeWaited),
timeWaited = timeWaited,
trialEarnings = trialEarnings,
nTimePoints = nTimePoints)
fit <- stan(model_code = modelString, data = data_list, cores = 1, chains = 1, iter = 500)
# set up
options(warn=-1, message =-1) # default settings borrowed somewhere
library(dplyr); library(ggplot2);library(reshape2); library('rstan'); #load libraries
Sys.setenv(USE_CXX14=1) # making rstan working on this device
rstan_options(auto_write = TRUE) # default settings borrowed somewhere
options(mc.cores = parallel::detectCores())# enable multi-core precessors
library('tidyr')
# fitting the model
source('subFxs/wtwSettings.R')
source('subFxs/fittingFxs.R')
load('outputs/fixInputSimData/initialSpace.RData') # need nComb(for loop), wIni, nPara(for initialize solutions)
# choose the condition
condIdx = 1
cond = conditions[condIdx]
wIni = wInis[[cond]]
tMax = ifelse(cond == 'HP', tMaxs[1], tMaxs[2])
nTimeStep = tMax / stepDuration
if(condIdx == 1){
load('outputs/fixInputSimData/rawHPData.RData')
timeWaitedList = rawHPData$timeWaited[,1,]
trialEarningsList = rawHPData$trialEarnings[,1,]
rm(rawHPData)
}else{
load('outputs/fixInputSimData/rawLPData.RData')
timeWaitedList = rawLPData$timeWaited[,1,]
trialEarningsList = rawLPData$trialEarnings[,1,]
rm(rawLPData)
}
# choose the combIdx
combIdx = 1
timeWaited = timeWaitedList[combIdx,];
trialEarnings = trialEarningsList[combIdx,];
nTimePoints = round(ifelse(trialEarnings >0, ceiling(timeWaited / stepDuration), floor(timeWaited / stepDuration) + 1))
data_list <- list(tMax = tMax,
wIni = wIni,
nTimeStep = nTimeStep,
N = length(timeWaited),
timeWaited = timeWaited,
trialEarnings = trialEarnings,
nTimePoints = nTimePoints)
# init = list(list('phi' = 0.5, 'tau' = 15, 'gamma' = 0.5),
#             list('phi' = 0.1, 'tau' = 5, 'gamma' = 0.1))
fit <- stan(file = 'stan/model.stan', data = data_list, cores = 2, chains = 2,
iter = 5000)
options(warn=-1, message =-1) # default settings borrowed somewhere
library(dplyr); library(ggplot2);library(reshape2); library('rstan'); #load libraries
Sys.setenv(USE_CXX14=1) # making rstan working on this device
rstan_options(auto_write = TRUE) # default settings borrowed somewhere
options(mc.cores = parallel::detectCores())# enable multi-core precessors
library('tidyr')
model = stan_model(file = "stan/model.stan")
for(i in 1: 125){
singleFittingStan(2, i)
}
source('~/Documents/first_kick/stan/singleFittingStan.R', echo=TRUE)
model = stan_model(file = "stan/model.stan")
for(i in 1: 125){
singleFittingStan(2, i)
}
options(warn=-1, message =-1) # default settings borrowed somewhere
library(dplyr); library(ggplot2);library(reshape2); library('rstan'); #load libraries
library('plyr')
Sys.setenv(USE_CXX14=1) # making rstan working on this device
rstan_options(auto_write = TRUE) # default settings borrowed somewhere
options(mc.cores = parallel::detectCores())# enable multi-core precessors
library('tidyr')
source('stan/singleFittingStan.R')
model = stan_model(file = "stan/model.stan")
for(i in 1: 125){
singleFittingStan(2, i)
}
options(warn=-1, message =-1) # default settings borrowed somewhere
library(dplyr); library(ggplot2);library(reshape2); library('rstan'); #load libraries
library('plyr')
Sys.setenv(USE_CXX14=1) # making rstan working on this device
rstan_options(auto_write = TRUE) # default settings borrowed somewhere
options(mc.cores = parallel::detectCores())# enable multi-core precessors
library('tidyr')
source('stan/singleFittingStan.R')
model = stan_model(file = "stan/model.stan")
for(i in 7: 125){
singleFittingStan(2, i)
}
model = stan_model(file = "stan/model.stan")
for(i in 1: 125){
singleFittingStan(2, i)
}
options(warn=-1, message =-1) # default settings borrowed somewhere
library(dplyr); library(ggplot2);library(reshape2); library('rstan'); #load libraries
library('plyr')
Sys.setenv(USE_CXX14=1) # making rstan working on this device
rstan_options(auto_write = TRUE) # default settings borrowed somewhere
options(mc.cores = parallel::detectCores())# enable multi-core precessors
library('tidyr')
source('stan/singleFittingStan.R')
model = stan_model(file = "stan/model.stan")
model = stan_model(file = "stan/model.stan")
for(i in 1: 81){
singleFittingStan(1, i)
}
